{"title":"Dijkstra","uid":"7ff27b21dc778d80ff5e8e51d9209bee","slug":"Dijkstra","date":"2022-03-08T15:28:56.000Z","updated":"2022-03-12T12:27:35.039Z","comments":true,"path":"api/articles/Dijkstra.json","keywords":null,"cover":null,"content":"<h2 id=\"单源最短路径\"><a href=\"#单源最短路径\" class=\"headerlink\" title=\"单源最短路径\"></a>单源最短路径</h2><span id=\"more\"></span>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;*\n·给定邻接矩阵G[][]\n·定义：1、int数组dis[]记录源点到各个节点最短距离。\n      2、bool数组fin[]记录各节点是否已经找到最小距离\n·初始化：dis[源点]&#x3D;0、dis[其余]&#x3D;Inf ;fin[源点]&#x3D;true 、fin[其余]&#x3D;false\n*&#x2F;\nconst int Inf &#x3D; (1&lt;&lt;31)-1;\nvoid Dijkstra(int G[][],int n)\n&#123;\n     int *dis &#x3D; new int(n);\n     bool *fin &#x3D; new bool(n);\n     memset(dis,Inf,sizeof(dis));\n     memset(fin,false,sizeof(fin));\n  dis[0] &#x3D; 0;\n     &#x2F;&#x2F;*********KeyCode***********\n     for(int i&#x3D;0;i&lt;n;i++)\n     &#123;\n       int u&#x3D;-1,min &#x3D; Inf;\n       for(int j&#x3D;0;j&lt;n;j++)&#x2F;&#x2F;找出本轮最小距离 用u暂存；\n       &#123;\n         if(fin[j]&#x3D;&#x3D;false &amp;&amp; dis[j]&lt;min)\n         &#123;\n           u &#x3D; j;\n           min &#x3D; dis[j];\n         &#125;\n       &#125;\n       if(u&#x3D;-1)break;\n       fin[u] &#x3D; true;\n       for(int v&#x3D;0;v&lt;n;v++)&#x2F;&#x2F;更新u邻居结点的距离\n       &#123;\n         if(fin[v]&#x3D;&#x3D;false &amp;&amp; G[u][v]+dis[u] &lt; dis[v])\n         &#123;\n           dis[v] &#x3D; G[u][v] + dis[u];\n         &#125;\n       &#125;\n     &#125;\n      &#x2F;&#x2F;*********KeyCode***********\n&#125;</code></pre>\n<h2 id=\"Prim-最小生成树MST（min-spanning-tree）\"><a href=\"#Prim-最小生成树MST（min-spanning-tree）\" class=\"headerlink\" title=\"Prim 最小生成树MST（min-spanning-tree）\"></a>Prim 最小生成树MST（min-spanning-tree）</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">const int inf &#x3D; 1&lt;&lt;30;\nvector&lt;vector&lt;int&gt;&gt;G(n,vector&lt;int&gt;(n));\n   vector&lt;int&gt;lowcost(n);\n   int sum&#x3D;0;\n   lowcost[0]&#x3D;0;\n   for(int i&#x3D;1;i&lt;n;i++)lowcost[i] &#x3D; G[0][i];\n   for(int i&#x3D;1;i&lt;n;i++)\n   &#123;\n       int min&#x3D;inf,k&#x3D;-1;\n       for(int j&#x3D;1;j&lt;n;j++) &#x2F;&#x2F;找出本轮lowcost中非零的最小权值 记录在min和K中\n       &#123;\n           if(lowcost[j]!&#x3D;0 &amp;&amp; lowcost[j]&lt;min)\n           &#123;\n               min &#x3D; lowcost[j];\n               k &#x3D; j;\n           &#125;\n       &#125;\n       &#x2F;&#x2F;******************\n       if(k&#x3D;&#x3D;-1)break;\n       lowcost[k] &#x3D; 0;\t\t&#x2F;&#x2F;选中当前最小结点 K， 令K的lowcost&#x3D;0\n       sum+&#x3D;min;\n       &#x2F;&#x2F;*******************\n       for(int j&#x3D;1;j&lt;n;j++)&#x2F;&#x2F;以K为主角去更新它的邻居节点的权值，\n       &#123;\n           if(lowcost[j]!&#x3D;0 &amp;&amp; G[k][j]&lt;lowcost[j])&#x2F;&#x2F;Dijkstra是dis[k]+G[k][j] &lt;dis[j]\n           &#123;\n               lowcost[j]&#x3D;G[k][j];\n           &#125;\n       &#125;\n   &#125;</code></pre>\n<h3 id=\"Dijkstra与Prim的区别\"><a href=\"#Dijkstra与Prim的区别\" class=\"headerlink\" title=\"Dijkstra与Prim的区别\"></a>Dijkstra与Prim的区别</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>·Dijkstra选择的是从源点处到当前结点的最短距离；<br>·Prim选择的是当前结点的到已经完结结点visit[i] &#x3D; true的最短距离；</p></blockquote>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include&lt;iostream&gt;\n #include&lt;vector&gt;\n#include&lt;math.h&gt;\nusing namespace std;\nconst int inf &#x3D; 1&lt;&lt;30;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;vector&lt;double&gt;&gt;G(n,vector&lt;double&gt;(n));\n    vector&lt;vector&lt;double&gt;&gt;coordinate(n,vector&lt;double&gt;(2));\n    \n    for(int i&#x3D;0;i&lt;n;i++)\n    &#123;\n        cin&gt;&gt;coordinate[i][0]&gt;&gt;coordinate[i][1];\n        for(int j&#x3D;0;j&lt;n;j++)\n            G[i][j]&#x3D;inf;\n    &#125;\n    for(int i&#x3D;0;i&lt;n-1;i++)\n    &#123;\n        for(int j&#x3D;i+1;j&lt;n;j++)\n        &#123;\n            double a&#x3D;coordinate[i][0]-coordinate[j][0];\n            double b&#x3D;coordinate[i][1]-coordinate[j][1];\n            a &#x3D; pow(a,2);\n            b &#x3D; pow(b,2);\n            G[i][j]&#x3D;G[j][i]&#x3D;sqrt(a+b);\n        &#125;\n    &#125;\n  \n    vector&lt;double&gt;lowcost(n);\n    double sum&#x3D;0;\n    lowcost[0]&#x3D;0;\n    for(int i&#x3D;1;i&lt;n;i++)lowcost[i] &#x3D; G[0][i];\n    for(int i&#x3D;1;i&lt;n;i++)\n    &#123;\n        double min&#x3D;inf,k&#x3D;-1;\n        for(int j&#x3D;1;j&lt;n;j++)\n        &#123;\n            if(lowcost[j]!&#x3D;0 &amp;&amp; lowcost[j]&lt;min)\n            &#123;\n                min &#x3D; lowcost[j];\n                k &#x3D; j;\n            &#125;\n        &#125;\n        if(k&#x3D;&#x3D;-1)break;\n        lowcost[k] &#x3D; 0;\n        sum+&#x3D;min;\n        for(int j&#x3D;1;j&lt;n;j++)\n        &#123;\n            if(lowcost[j]!&#x3D;0 &amp;&amp; G[k][j]&lt;lowcost[j])\n            &#123;\n                lowcost[j]&#x3D;G[k][j];\n            &#125;\n        &#125;\n    &#125;\n    printf(&quot;%.2lf&quot;,sum);\n    return 0;\n&#125;</code></pre>\n\n","text":"单源最短路径 &#x2F;* ·给定邻接矩阵G[][] ·定义：1、int数组dis[]记录源点到各个节点最短距离。 2、bool数组fin[]记录各节点是否已经找到最小距离 ·初始化：dis[源点]&#x3D;0、dis[其余]&#x3D;Inf ;fin[源点]&#x3D;t...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"algorithm","slug":"algorithm","count":4,"path":"api/tags/algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">单源最短路径</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Prim-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91MST%EF%BC%88min-spanning-tree%EF%BC%89\"><span class=\"toc-text\">Prim 最小生成树MST（min-spanning-tree）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dijkstra%E4%B8%8EPrim%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">Dijkstra与Prim的区别</span></a></li></ol></li></ol>","author":{"name":"Lkh","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"中国剩余定理","uid":"b6cf2bc1f982cde92ae567cafd18a8a1","slug":"中国剩余定理","date":"2022-03-14T12:43:51.000Z","updated":"2022-03-14T13:12:15.134Z","comments":true,"path":"api/articles/中国剩余定理.json","keywords":null,"cover":null,"text":" 又名“孙子定理”， 《孙子算经》中第二十六题【原文】：：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？答曰：‘二十三’。术曰：三三数之剩二，置一百四十；五五数之剩三，置六十三，七七数之剩二，置三十，并之。得二百三十三，以二百一十减之，即得。凡三三数之剩一，...","link":"","photos":[],"count_time":{"symbolsCount":928,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"数论","slug":"数论","count":1,"path":"api/tags/数论.json"}],"author":{"name":"Lkh","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"摘录与感悟","uid":"068ecfc1151b185a3dd09eb4e4fa4457","slug":"摘录与感悟","date":"2022-03-07T15:00:54.000Z","updated":"2022-03-15T11:17:40.578Z","comments":true,"path":"api/articles/摘录与感悟.json","keywords":null,"cover":null,"text":"一些句子 忠厚老实人的恶毒，像饭里的砂砾，或者出骨鱼片里未净的刺，会给人一种不期待的伤痛。​ —-《围城》 你若问人问题，他答非所问，便已是答了，毋需再问。 —《素履之往》​ 世上的事，说足了这头，便开始说那头 —-《俗世奇人》​ 如果失望了肯定是附加了一些不切实际的期望在她身上...","link":"","photos":[],"count_time":{"symbolsCount":996,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"随笔","slug":"随笔","count":1,"path":"api/tags/随笔.json"}],"author":{"name":"Lkh","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}