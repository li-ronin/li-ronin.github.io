[{"id":"858dfc91504ed7fb108cacb904a43d3a","title":"tite","content":"","slug":"tite","date":"2023-04-11T08:33:54.000Z","categories_index":"","tags_index":"","author_index":"Lkh"},{"id":"5e05676005a67b187c728a6e49c065fb","title":"遗传算法","content":"\n\n\n\n\n\n\n\n\n前言：Genetic Algorithm（简称GA），人工智能的重要分支，用计算机模拟生命进化机制而发展起来的学科，通过适者生存机制来搜索计算和问题求解。遗传算法具有普适性，不依赖优化对象的模型，也就是说无需知道优化目标函数长啥样的，完全就靠采样就可以了。但普适性强就势必意味着针对性弱，简单来说就是 对什么问题都能用的算法，那一定对特定某一类问题效果不好。 No Free Lunch .\n\n\n关于遗传算法先进行定向选择，再进行不定项的变异step1：随机生成一个群体。随机选第一批种子选手作为父本step2：设定适应度函数。快者生存，跑得快的更容易活下去，跑得慢的更容易死step3：产生后代。第一批父本幸存者产后代（产生均匀&#x2F;非均匀变异step4：迭代\n遗传算法的基本要素包括染色体编码方法、适应度函数、遗传操作和运行参数。其中：1、染色体编码方法是指个体的编码方法,目前包括二进制法、实数法等。二进制法是指把个体编码成为一个二进制串,实数法是指把个体编码成为一个实数串。2、适应度函数是指根据进化目标编写的计算个体适应度值的函数,通过适应度函数计算每个个体的适应度值,提供给选择算子进行选择。3、遗传操作是指选择操作、交叉操作和变异操作。4、运行参数是遗传算法在初始化时确定的参数,主要包括：群体大小 M,遗传代数G,交叉概率Pc和变异概率Pm。\n\n\n标准遗传算法\n选择算法\n交叉算法\n变异算法\n\n\n\n\n\n\n\n\n\n\n\n数学模型可表示为：SAG&#x3D;（C，E,  P0,  N,  Φ， Γ， ψ， Τ）C：个体编码方式E：个体的适应度评价函数（又称目标函数，用来随机淘汰样本）P0：初始种群（父本）N： 种群大小Φ：选择算子Γ： 交叉算子ψ：变异算子Τ：遗传运算的终止条件\n适用场景\n场景1: 神经网络超参数优化\n场景2: 一部分结构和特性固定的组合优化问题\n场景3: 一部分机理模型难以建立的黑箱优化问题\n场景4: 多目标优化问题\n\n遗传算法为代表的进化计算方法主要还是捡数学优化的漏，优先考虑数学优化方法，当数学优化解决不了的时候再考虑遗传算法。当一类问题采用遗传算法时基本上代表这是没有办法的办法了。\n编码方式\n二进制编码\n\n\n\n\n\n\n\n\n优点： 1. 编码、解码操作简单易行 2. 交叉、变异等遗传操作便于实现 3. 合最小字符集编码原则 4. 利用模式定理对算法进行理论分析。\n\n\n\n\n\n\n\n\n\n\n\n缺点：对于一些连续函数的优化问题，由于其随机性使得其局部搜索能力较差，如对于一些高精度的问题，当解迫近于最优解后，由于其变异后表现型变化很大，不连续，所以会远离最优解，达不到稳定。\n\n格雷码\n\n\n\n\n\n\n\n\n\n优点：增强遗传算法的局部搜索能力，便于对连续函数进行局部空间搜索。使用非常广泛。\n\n浮点编码法\n\n\n\n\n\n\n\n\n\n优点：1、适用于在遗传算法中表示范围较大的数2、适用于精度要求较高的遗传算法3、便于较大空间的遗传搜索4、改善了遗传算法的计算复杂性，提高了运算交率5、便于遗传算法与经典优化方法的混合使用6、便于设计针对问题的专门知识的知识型遗传算子7、便于处理复杂的决策变量约束条件\n\n符号编码\n\n\n\n\n\n\n\n\n\n优点：1、符合有意义积术块编码原则2、便于在遗传算法中利用所求解问题的专门知识3、便于遗传算法与相关近似算法之间的混合使用。\n\n\n选择算子\n二元锦标赛选择从父代种群中随机选择2个个体，比较2个个体的适应度值，选择适应度更佳的个体参与下一环节的“交叉”和“变异”。\nfunctiom p &#x3D; BTS(Parent)\nnum &#x3D; numel(Parent);\nindex &#x3D; randperm(num); % 1~num的乱序数组\nplayers &#x3D; Parent(index（1:2）);%把随机Parent的下标index[1]和index[2]给players\n%写法一：\n[~,pos] &#x3D; sort([players.fitness],&#39;descend&#39;);%pos是sort排序返回的下标，~不接收\np &#x3D; players(pos(1));\n%写法二：\nif palyers(1).fitness &gt; palyers(2).fitness\t%选适应度大的个体\n\tp &#x3D; palyers(1);\nelse\n\tp &#x3D; palyers(2);\nend\nend\t\n【注】\n%********结构体排序****************\n t.x&#x3D;[];   t.y&#x3D;[];\n P &#x3D; repmat(t,10,1)\n      for i&#x3D;1:10\nP(i).x &#x3D; randi([1,10],1,5);\nP(i).y &#x3D;sum(P(i).x);\n      end\n [A,pos] &#x3D; sort([P.y],&#39;ascend&#39;)\n %A是排好序的P.y\n A &#x3D;  13    16    22    29    29    30    31    32    32    44\n %pos是P.y的下标\n pos &#x3D;3     8      9      5      6      2      7     1     10     4\n\n多元锦标赛选择从父代种群中随机选择N个个体，比较N个个体的适应度值，选择适应度更佳的个体参与下一环节的“交叉”和“变异”。\n function p &#x3D; MTS(Parent,count)\n  n &#x3D; numel(Parent);\n  if count&gt;&#x3D;n\n      error(&#39;设置的选择个数必须小于父代种群规模&#39;);\n  else\n       index &#x3D; randperm(n);\n       players &#x3D; Parent(index(1:count));\n       [~,pos] &#x3D; sort([players.fitness],&#39;descend&#39;);\n       p &#x3D; players(pos(1));\n  end\nend\n\n轮盘赌选择1、计算每个个体的相对适应度值；2、计算每个个体的累计概率；2、转动轮盘选择个体，被选中的概率与个体适应度值成正比\n %轮盘赌选择法\nfunction p &#x3D; RWS(Parent)\n    Px &#x3D; [Parent.fitness] .&#x2F; sum([Parent.fitness]); %计算相对适应度\n    Cx &#x3D; cumsum(Px);                                %累计概率\n    r &#x3D; rand;                                       %产生随机数r\n    i &#x3D; find(r&lt;&#x3D; Cx,1,&#39;first&#39;);                     %找到随机点落的区间\n    p &#x3D; Parent(i);\nend\n\n交叉算子\n单点交叉\n\n多点交叉\n\n均匀交叉\n\n\n变异算子遗传算法的有效性\n模式定理\n积木块假设\n\n","slug":"遗传算法","date":"2022-04-03T07:17:11.000Z","categories_index":"","tags_index":"遗传算法","author_index":"Lkh"},{"id":"b6cf2bc1f982cde92ae567cafd18a8a1","title":"中国剩余定理","content":"\n\n\n\n\n\n\n\n\n又名“孙子定理”，\n\n\n\n\n\n\n\n\n\n\n《孙子算经》中第二十六题【原文】：：今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？答曰：‘二十三’。术曰：三三数之剩二，置一百四十；五五数之剩三，置六十三，七七数之剩二，置三十，并之。得二百三十三，以二百一十减之，即得。凡三三数之剩一，则置七十；五五数之剩一，则置二十一；七七数之剩一，则置十五；一百六以上以一百五减之即得。 \n\n\n\n\n\n\n\n\n\n\n即：一个整数除以3余2、除以5余3、除以7余2，求这个整数。答案：23解法：由于除以3余2，因此加上一个140；由于除以5余3，因此加上一个63；由于除以7余2，因此加上一个30；这三个数的和是140+63+30&#x3D;233，再减去210，就得到了23了。这么说吧，&#x3D;&#x3D;只要是除以3余了一个1，就加上一个70；只要是除以5余了一个1，就加上一个21；只要是除以7余了一个1，就加上一个15。然后累加。超过了106就减去105就行了。&#x3D;&#x3D;\n问题分解Q1：计算一个整数x,满足除以3余2、除以5余3、除以7余2。找到三个数$x_1$、$x_2$、$x_3$，分别满足：\n\n$x_1$   除以$3$余2，除以$5$余 0，除以$7$余0;\n$x_1$   除以$3$余0，除以$5$余3，除以$7$余0;\n$x_1$   除以$3$余0，除以$5$余0，除以$7$余2;$x &#x3D; x_1+x_2+x_3$\n\n子问题那么寻找$x_1$、$x_2$、$x_3$，视为三个子问题   $Q1.1$、$Q1.2$、$Q1.3$ :\n\n$Q1.1$为：寻找整数 $y_1$满足 $y_1$除以3余1、除以5余0、除以7余0； 显然是70\n\n$Q1.2$为：寻找整数 $y_2$ 满足 $y_2$ 除以3余0、除以5余1、除以7余0；显然是21\n\n$Q1.3$为：寻找整数 $y_3$满足 $y_3$除以3余0、除以5余0、除以7余1。 显然是15于是就可以取$x &#x3D; y_12+y_23+y_32$。即 x&#x3D;(140+63+30)%(35*7)&#x3D;23\n\n\n","slug":"中国剩余定理","date":"2022-03-14T12:43:51.000Z","categories_index":"","tags_index":"数论","author_index":"Lkh"},{"id":"7ff27b21dc778d80ff5e8e51d9209bee","title":"Dijkstra","content":"单源最短路径\n&#x2F;*\n·给定邻接矩阵G[][]\n·定义：1、int数组dis[]记录源点到各个节点最短距离。\n      2、bool数组fin[]记录各节点是否已经找到最小距离\n·初始化：dis[源点]&#x3D;0、dis[其余]&#x3D;Inf ;fin[源点]&#x3D;true 、fin[其余]&#x3D;false\n*&#x2F;\nconst int Inf &#x3D; (1&lt;&lt;31)-1;\nvoid Dijkstra(int G[][],int n)\n&#123;\n     int *dis &#x3D; new int(n);\n     bool *fin &#x3D; new bool(n);\n     memset(dis,Inf,sizeof(dis));\n     memset(fin,false,sizeof(fin));\n  dis[0] &#x3D; 0;\n     &#x2F;&#x2F;*********KeyCode***********\n     for(int i&#x3D;0;i&lt;n;i++)\n     &#123;\n       int u&#x3D;-1,min &#x3D; Inf;\n       for(int j&#x3D;0;j&lt;n;j++)&#x2F;&#x2F;找出本轮最小距离 用u暂存；\n       &#123;\n         if(fin[j]&#x3D;&#x3D;false &amp;&amp; dis[j]&lt;min)\n         &#123;\n           u &#x3D; j;\n           min &#x3D; dis[j];\n         &#125;\n       &#125;\n       if(u&#x3D;-1)break;\n       fin[u] &#x3D; true;\n       for(int v&#x3D;0;v&lt;n;v++)&#x2F;&#x2F;更新u邻居结点的距离\n       &#123;\n         if(fin[v]&#x3D;&#x3D;false &amp;&amp; G[u][v]+dis[u] &lt; dis[v])\n         &#123;\n           dis[v] &#x3D; G[u][v] + dis[u];\n         &#125;\n       &#125;\n     &#125;\n      &#x2F;&#x2F;*********KeyCode***********\n&#125;\nPrim 最小生成树MST（min-spanning-tree）const int inf &#x3D; 1&lt;&lt;30;\nvector&lt;vector&lt;int&gt;&gt;G(n,vector&lt;int&gt;(n));\n   vector&lt;int&gt;lowcost(n);\n   int sum&#x3D;0;\n   lowcost[0]&#x3D;0;\n   for(int i&#x3D;1;i&lt;n;i++)lowcost[i] &#x3D; G[0][i];\n   for(int i&#x3D;1;i&lt;n;i++)\n   &#123;\n       int min&#x3D;inf,k&#x3D;-1;\n       for(int j&#x3D;1;j&lt;n;j++) &#x2F;&#x2F;找出本轮lowcost中非零的最小权值 记录在min和K中\n       &#123;\n           if(lowcost[j]!&#x3D;0 &amp;&amp; lowcost[j]&lt;min)\n           &#123;\n               min &#x3D; lowcost[j];\n               k &#x3D; j;\n           &#125;\n       &#125;\n       &#x2F;&#x2F;******************\n       if(k&#x3D;&#x3D;-1)break;\n       lowcost[k] &#x3D; 0;\t\t&#x2F;&#x2F;选中当前最小结点 K， 令K的lowcost&#x3D;0\n       sum+&#x3D;min;\n       &#x2F;&#x2F;*******************\n       for(int j&#x3D;1;j&lt;n;j++)&#x2F;&#x2F;以K为主角去更新它的邻居节点的权值，\n       &#123;\n           if(lowcost[j]!&#x3D;0 &amp;&amp; G[k][j]&lt;lowcost[j])&#x2F;&#x2F;Dijkstra是dis[k]+G[k][j] &lt;dis[j]\n           &#123;\n               lowcost[j]&#x3D;G[k][j];\n           &#125;\n       &#125;\n   &#125;\nDijkstra与Prim的区别\n\n\n\n\n\n\n\n\n·Dijkstra选择的是从源点处到当前结点的最短距离；·Prim选择的是当前结点的到已经完结结点visit[i] &#x3D; true的最短距离；\n#include&lt;iostream&gt;\n #include&lt;vector&gt;\n#include&lt;math.h&gt;\nusing namespace std;\nconst int inf &#x3D; 1&lt;&lt;30;\nint main()\n&#123;\n    int n;\n    cin&gt;&gt;n;\n    vector&lt;vector&lt;double&gt;&gt;G(n,vector&lt;double&gt;(n));\n    vector&lt;vector&lt;double&gt;&gt;coordinate(n,vector&lt;double&gt;(2));\n    \n    for(int i&#x3D;0;i&lt;n;i++)\n    &#123;\n        cin&gt;&gt;coordinate[i][0]&gt;&gt;coordinate[i][1];\n        for(int j&#x3D;0;j&lt;n;j++)\n            G[i][j]&#x3D;inf;\n    &#125;\n    for(int i&#x3D;0;i&lt;n-1;i++)\n    &#123;\n        for(int j&#x3D;i+1;j&lt;n;j++)\n        &#123;\n            double a&#x3D;coordinate[i][0]-coordinate[j][0];\n            double b&#x3D;coordinate[i][1]-coordinate[j][1];\n            a &#x3D; pow(a,2);\n            b &#x3D; pow(b,2);\n            G[i][j]&#x3D;G[j][i]&#x3D;sqrt(a+b);\n        &#125;\n    &#125;\n  \n    vector&lt;double&gt;lowcost(n);\n    double sum&#x3D;0;\n    lowcost[0]&#x3D;0;\n    for(int i&#x3D;1;i&lt;n;i++)lowcost[i] &#x3D; G[0][i];\n    for(int i&#x3D;1;i&lt;n;i++)\n    &#123;\n        double min&#x3D;inf,k&#x3D;-1;\n        for(int j&#x3D;1;j&lt;n;j++)\n        &#123;\n            if(lowcost[j]!&#x3D;0 &amp;&amp; lowcost[j]&lt;min)\n            &#123;\n                min &#x3D; lowcost[j];\n                k &#x3D; j;\n            &#125;\n        &#125;\n        if(k&#x3D;&#x3D;-1)break;\n        lowcost[k] &#x3D; 0;\n        sum+&#x3D;min;\n        for(int j&#x3D;1;j&lt;n;j++)\n        &#123;\n            if(lowcost[j]!&#x3D;0 &amp;&amp; G[k][j]&lt;lowcost[j])\n            &#123;\n                lowcost[j]&#x3D;G[k][j];\n            &#125;\n        &#125;\n    &#125;\n    printf(&quot;%.2lf&quot;,sum);\n    return 0;\n&#125;\n\n","slug":"Dijkstra","date":"2022-03-08T15:28:56.000Z","categories_index":"","tags_index":"algorithm","author_index":"Lkh"},{"id":"068ecfc1151b185a3dd09eb4e4fa4457","title":"摘录与感悟","content":"一些句子\n\n\n\n\n\n\n\n\n\n\n忠厚老实人的恶毒，像饭里的砂砾，或者出骨鱼片里未净的刺，会给人一种不期待的伤痛。​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   —-《围城》\n\n\n\n\n\n\n\n\n\n你若问人问题，他答非所问，便已是答了，毋需再问。    —《素履之往》​                                                       \n\n\n\n\n\n\n\n\n\n世上的事，说足了这头，便开始说那头     —-《俗世奇人》​\t\t\t\t\t\t    \n\n\n\n\n\n\n\n\n\n如果失望了肯定是附加了一些不切实际的期望在她身上​\t\t\t\t\t\t     \n\n\n\n\n\n\n\n\n\n生活不会摆摆手叫你过来，慢悠悠的讲给你听，它只会给你两巴掌，然后说：你小子学着点。​\t\n\n\n\n\n\n\n\n\n\n趁着年轻生猛，我要再和生活死磕几年。要么我就毁灭，要么我就铸就辉煌。如果有一天，你发现我在平庸面前低了头，请向我开炮。​\t\n\n\n\n\n\n\n\n\n\n你要分得清冷静与冷漠，区分开坚持和固执，对自己不失信，说想说的话，见想见的人。你看这年复一年，春光不必趁早，冬霜不会迟到，相聚别离都是刚刚好，自先沉稳而后爱人。​\t\n\n\n\n\n\n\n\n\n\n事实上，苦难就是苦难，苦难本身不会带来成功。人们歌颂的从来不是苦难，而是经历苦难没有被击倒，反而散发出的人性光辉。​\t\n\n\n\n\n\n\n\n\n\n雪没了，冬天还在​\t\n\n\n\n\n\n\n\n\n\n一个人觉得努力就会与回报，这本身就是一种傲慢。​                                                      —–《强风吹拂》\n一些读后感\n\n\n\n\n\n\n\n\n真正伟大的事业、理想亦或艺术，并不是有人帮忙打理了一切，然后在乌托邦这样的地方，专注地迸发出来的，而是在每天六便士的柴米油盐之下，怀着异乎寻常的坚定信念仰望着月亮，不断追求、不断生活，最终成为诞生于世俗中的理想之花，可能这朵生长在六便士之中，却沐浴在月光之下的花朵才是更多伟大的真相吧         ——《月亮与六便士》​\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n很长一段时间，我的生活看似马上要开始了—-真正的生活。但是总有一些阻碍阻拦着，有些事得先解决，有些工作待完成，时间貌似够用，还有一些欠的东西要还清，然后生活就会开始步入正轨了。可是慢慢的我终于明白，这些障碍啊正是我的生活本身，未来即是当下。​\t\n","slug":"摘录与感悟","date":"2022-03-07T15:00:54.000Z","categories_index":"","tags_index":"随笔","author_index":"Lkh"},{"id":"d843ced03f40ac612213952de4b63ad2","title":"二分查找","content":"·二分查找\n\n\n\n\n浅查一下吧&#x2F;&#x2F;查找有序表中第一个出现的元素K（lower&#x3D;1）,最后一个出现的元素K(lower&#x3D;1)\nint BiSearch(int A[],int K,int lower)\n\t&#123;\n      int left&#x3D;0 , right&#x3D;A.size()-1 , mid;\n      while(left&lt;&#x3D;right)\n      &#123;\n        mid &#x3D; left + (right-left)&#x2F;2;\n        if(A[mid]&lt;K || (lower&amp;&amp;A[mid]&#x3D;&#x3D;K))\n        \tleft &#x3D; mid+1;\n        else\n        \tright &#x3D; mid-1;\n      &#125;\n      return left;\n\t&#125;\n快速幂long long fastpow(long long a,long long b)&#x2F;&#x2F;求a^b\n&#123;\n\tlong long sum&#x3D;1,base&#x3D;a;\n     \twhile(b!&#x3D;0)\n     \t&#123;\n       \tif(b%2 &#x3D;&#x3D; 1)sum *&#x3D; base;\n       \tbase *&#x3D; base;\n       \tb &#x2F;&#x3D; 2;\n     \t&#125;\n     \treturn sum;\n&#125;\n","slug":"二分查找","date":"2022-03-07T14:29:22.000Z","categories_index":"","tags_index":"algorithm","author_index":"Lkh"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"\n\n\n\n\n\n\n\n\n树与图\n\n\n并 Union 查 Find  集 Set\n\n\n\n\n\n\n\n\n利用数组 int father[N] 来实现并查集产生的每一个集合都是一棵树，即不会产生环。\n操作1、 初始化\n\n\n\n\n\n\n\n\n\n初始化 father[]数组，一开始每一个元素都是一个集合（自成孤岛），令father[i] &#x3D; i;\nfor(int i&#x3D;1;i&lt;&#x3D;N;i++)&#123;\n\tfather[i] &#x3D; i;\n&#125;\n2、 查找\n\n\n\n\n\n\n\n\n\n一个集合中只存在一个根节点，即找爹函数\nint Find(int x)\n&#123;\n     while(father[x]!&#x3D;x)\n     &#123;\n       x &#x3D; father[x];\n     &#125;\n     return x; \n&#125;\n3、 合并\n\n\n\n\n\n\n\n\n\n把两个集合合并为一个集合先判断两个元素是否属于一个集合，不同才合并：把其中一个集合的根节点的父亲设置为另一个集合的根节点\nvoid Union(int a,int b)\n&#123;\n     int rootA &#x3D; Find(a);\n     int rootB &#x3D; Find(b);\n     if(rootA !&#x3D; rootB)\n     &#123;\n       father[rootA] &#x3D; rootB;\n     &#125;\n&#125;\n","slug":"并查集","date":"2022-03-07T04:28:31.000Z","categories_index":"","tags_index":"algorithm","author_index":"Lkh"},{"id":"f6af5bf3fb5f66f52237908153c03aea","title":"动态规划","content":"\n\n\n\n\n\n\n\n\n例：用2、5、7元硬币凑出正好27元，且要求硬币数量最少。##1、类型\n\n计数型\n最值型\n存在型\n\n2、思路与步骤①确定状态1、f(x)或者f(x)(y)代表什么：凑出x元所需最少硬币数量2、最后一步代表什么； $a_1 + a_2 + a_3\\cdots+a_k$ ,最后一枚硬币$a_k$\n3、化为问题相同但是规模更小的子问题: $27-a_k$最少由k-1枚硬币凑成\n②确定转移方程$$f[27] &#x3D; min{f[27-2],f[27-5],f[27-7]} $$\n③确定初始条件与边界\nx-2,x-5,x-7小于零的时候说明凑不出来Y，令f[Y]&#x3D;+∞\nf[0] &#x3D; 0\n\n④确定运算顺序3、背包九讲\n\n\n\n\n\n\n\n\n基础背包问题：有N件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。\n特点：每种物品仅有一件，可以选择放或不放。\n类型\n0–1背包：每个物品只有一个\n完全背包：每个物品无限多个\n多重背包：每个物品特定数量\n混合背包：\n二维费用的背包\n分组背包\n背包问题求方案数\n最优物品选择方案\n有依赖的背包\n\n","slug":"动态规划","date":"2022-03-02T10:48:14.000Z","categories_index":"","tags_index":"动态规划","author_index":"Lkh"},{"id":"dca193cd3708bfa4a4816acdfe93287d","title":"简单算法模板","content":"\n\n\n\n\n\n\n\n\nThis is a template of sample algorithm that records my pushing process\n\n·树定义与构造函数struct BiTree&#123;\n     char data;\n     struct BiTree *lchild;\n     struct BiTree *rchild;\n     BiTree(char c):data(c),lchild(NULL),rchild(NULL)&#123;&#125;\n     BiTree(char c,BiTree *L,BiTree *R):data(c),lchild(L),rchild(R)&#123;&#125;\n&#125;;\n建树&#x2F;&#x2F;已知先序遍历(空节点用‘#’表示) 来建树\nBiTree* PreOrder_BulidTree(string str)\n&#123;\n     char c &#x3D; str[pos++];\n     if(c&#x3D;&#x3D;&#39;#&#39;)return NULL;\n     BiTree *root &#x3D; new BiTree(c);\n     root-&gt;left &#x3D; PreOrder_BulidTree(str);\n     root-&gt;right &#x3D; PreOrder_BulidTree(str);\n     return root;\n&#125;\n遍历void MidOrder(BiTree *root)&#x2F;&#x2F;中 ，前后同理。 层序见BFS\n&#123;\n     \tif(root &#x3D;&#x3D; NULL)return ;\n     \tMidOrder(root-&gt;lchild);\n     \tcout&lt;&lt;root-&gt;data;\n     \tMidOrder(root-&gt;rchild);\n&#125;\nDFSvoid DFS(int node) &#x2F;&#x2F;图\n&#123;\n     visit[node] &#x3D; true;\n     for(int i&#x3D;0;i&lt;n;i++)\n     &#123;\n       if(visit[i]&#x3D;&#x3D;false &amp;&amp; G[node][i]!&#x3D;Ifo)\n       \tDFS(i);\n     &#125;\n&#125;\n&#x2F;&#x2F;DFS求二叉树高度\nint maxdeep(BiTree *root)\n&#123;\n     if(root &#x3D;&#x3D; NULL)return 0;\n     return max(maxdeep(root-&gt;lchild),maxdeep(root-&gt;rchild))+1;\n&#125;\n&#x2F;&#x2F;DFS判断平衡二叉树高度是否平衡\nbool isbalance(BiTree *root)\n&#123;\n     if(root &#x3D;&#x3D; NULL)return true;\n     return abs(maxdeep(root-&gt;lchild)-maxdeep(root-&gt;rchild))&lt;&#x3D;1 &amp;&amp; isbalance(root-&gt;lchild) &amp;&amp; isbalance(root-&gt;rchild);\n&#125;\n\n习题\n\n\n\n\n\n\n\n\n100. Same Tree101. Symmetric Tree110. Balanced Binary Tree257. Binary Tree Paths1013 Battle Over Cities\n\n\nBFSvoid BFS(BiTree *root)\n&#123;\n     queue&lt;BiTree*&gt;Q;\n     Q.push(root);\n     int level&#x3D;0;\n     while(!Q.empty())\n     &#123;\n       int size &#x3D; Q.size();\n       for(int i&#x3D;0;i&lt;size;i++)\n       &#123;\n       \tBiTree *temp &#x3D; Q.front();\n       \tQ.pop();\n       \tif(temp-&gt;lchild !&#x3D; NULL)Q.push(temp-&gt;lchild);\n       \tif(temp-&gt;rchild !&#x3D; NULL)Q.push(temp-&gt;rchild);\n       &#125;\n       level++;\n     &#125;\n&#125;\n\n· sort快排int Partition(int A[],int low,int high)\n&#123;\n     int pivot &#x3D; A[low];\n     while(low&lt;high)\n     &#123;\n       while(low&lt;high &amp;&amp; A[high]&gt;pivot)high--;\n       A[low] &#x3D; A[high];\n       while(low&lt;high &amp;&amp; A[low]&lt;pivot)low++;\n       A[high] &#x3D; A[low];\n     &#125;\n     A[low] &#x3D; pivot;\n     return low;\n&#125;\nvoid FastSort(int A[],int low,int high)\n&#123;\n     if(low&lt;high)\n     &#123;\n       int pivot &#x3D; Partition(A,low,high);\n       FastSort(A,low,pivot-1);\n       FastSort(A,pivot+1,high);\n     &#125;\n&#125;\n归并&#x2F;&#x2F;A[]好像是伪代码\nint *B &#x3D; new int(high+1);\nvoid Merge(int A[],int low,int mid,int high)\n&#123;\n     for(int i&#x3D;low;i&lt;&#x3D;high;i++)\n     \tB[i] &#x3D; A[i];\n     int i&#x3D;low,j&#x3D;mid+1,k&#x3D;low;\n     while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;high)\n     &#123;\n     \tif(A[i]&lt;A[j])\n     \t&#123;\n         B[k++] &#x3D; A[i++];\n     \t&#125;else\n     \t&#123;\n         B[k++] &#x3D; A[j++];\n     \t&#125;\n     &#125;\n     while(i&lt;&#x3D;mid)B[k++] &#x3D; A[i++];\n     while(j&lt;&#x3D;high)B[k++] &#x3D; A[j++];\n&#125;\nvoid MergeSort(int A[],int low,int high)\n&#123;\n     if(low&lt;high)\n     &#123;\n       mid &#x3D; (low+high)&#x2F;2;\n       MergeSort(A,low,mid);\n       MergeSort(A,mid+1,high);\n       Merge(A,low,mid,high);\n     &#125;\n&#125;\nBubblevoid Bubble(vector&lt;int&gt;&amp;v,int n)\n&#123;\n     for(int i&#x3D;0;i&lt;n;i++)\n     &#123;\n     \tint flag &#x3D; -1;\n       for(int j&#x3D;n-1;j&gt;i;j--)\n       &#123;\n         if(v[j]&lt;v[j-1])\n         &#123;\n           swap(v[j],v[j-1]);\n           flag &#x3D; 1;\n         &#125;\n       &#125;\n       if(flag&#x3D;&#x3D;-1)break;\n     &#125;\n&#125;\n\n\n·进制问题大数进制&#x2F;&#x2F;从form进制 转换为 to进制 得到的res是逆置的 还需要颠倒一下\nstring conversion(string num,int from,int to)\n&#123;\n     string res&#x3D;&quot;&quot;;\n     int len&#x3D;num.length();\n     for(int i&#x3D;0;i&lt;len;)\n     &#123;\n     \tint k&#x3D;0;\n       for(int j&#x3D;i;j&lt;len;j++)\n       &#123;\n         int temp &#x3D; (k*from + num[j]-&#39;0&#39;)%to;\n         num[j] &#x3D; (k*from + num[j]-&#39;0&#39;)&#x2F;b + &#39;0&#39;;\n         k &#x3D; temp;\n       &#125;\n       res +&#x3D; (k+&#39;0&#39;);\n       while(num[i] &#x3D;&#x3D; &#39;0&#39;)i++;\n     &#125;\n     return res;\n&#125;\n\n·数字的旋转左移\n\n\n\n\n\n\n\n\n十进制整型在不转换为二进制的情况下对机器码循环左移（右同理），第11行※\nint a,b;\ncin&gt;&gt;a&gt;&gt;b;&#x2F;&#x2F;保证a、b&lt; 65536，那么有效数字位数为低16位\nint flag&#x3D;false;\nfor(int i&#x3D;0;i&lt;16;i++)\n&#123;\n     if(a&#x3D;&#x3D;b)\n     &#123;\n       flag&#x3D;true;&#x2F;&#x2F;a和b在旋转左移任意位后是相等的\n       break;\n     &#125;\n     a &#x3D; (((a&gt;&gt;15)&amp;1)|(a&lt;&lt;1))&amp;0xffff;&#x2F;&#x2F;a的二进制旋转左移，无须将十进制转换为二进制就可以实现\n&#125;\nif(flag)cout&lt;&lt;&quot;a&#x3D;&#x3D;b&quot;&lt;&lt;endl;\nelse cout&lt;&lt;&quot;a!&#x3D;b&quot;&lt;&lt;endl;\n\n\n\n\n\n\n\n\n\n\n","slug":"简单算法模板","date":"2022-03-02T04:48:03.000Z","categories_index":"","tags_index":"algorithm","author_index":"Lkh"}]